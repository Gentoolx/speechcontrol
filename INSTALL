Installing SpeechControl (with package installation instructions for Ubuntu)
=================

0. For the Impatient (TL;DR)

    # apt-get install libpocketsphinx-dev libsphinxbase-dev gstreamer0.10-pocketsphinx python-gst0.10-dev python3-pyqt4
    $ cd speechcontrol
    $ python setup.py build
    # python setup.py install
    (for maintainers) $ python setup.py sdist

1. Required Packages

SpeechControl requires that you have the following packages installed:

    * PyQt4 Qt bindings for Python
      # apt-get install python3-pyqt4

    * GStreamer 0.10 generic media-playing framework
      # apt-get install python-gst0.10-dev

    * CMUSphinx's PocketSphinx speech recognition library and its development
      files as well as the needed GStreamer elements
      # apt-get install libpocketsphinx-dev libsphinxbase-dev gstreamer0.10-pocketsphinx

    * [Optional] Development files for kdelibs (4.7.2 or higher)
      # apt-get install kdelibs5-dev

2. Configuration

Configuration is done via Python Distutils. SpeechControl should handle
every standard option.

3. Building

To build SpeechControl, invoke the setup.py script.

    $ python setup.py build

You will find scripts, modules and data under 'build' directory.

4. Running

You can invoke SpeechControl directly from the 'speechcontrol' directory
under the project root (probably top Git repository directory).

5. Testing

You can test parts of SpeechControl and submit loads of information for
developers, packagers and future testers to determine what and where needs
to be tweaked so that SpeechControl can be properly built across multiple
systems. Part of the information sent back to the Synthetic Intellect Institute
development's CDash system looks like this (taken from JackyAlcine's system):

<Site BuildName="Linux-c++"
    BuildStamp="20120220-2311-Continuous"
    Name="tafc-desktop"
    Generator="ctest-2.8.5"
    CompilerName="/usr/bin/c++"
    OSName="Linux"
    Hostname="tafc-desktop"
    OSRelease="3.0.0-16-generic"
    OSVersion="#29-Ubuntu SMP Tue Feb 14 12:49:42 UTC 2012"
    OSPlatform="i686"
    Is64Bits="0"
    VendorString="GenuineIntel"
    VendorID="Intel Corporation"
    FamilyID="6"
    ModelID="15"
    ProcessorCacheSize="1024"
    NumberOfLogicalCPU="2"
    NumberOfPhysicalCPU="2"
    TotalVirtualMemory="3906"
    TotalPhysicalMemory="3016"
    LogicalProcessorsPerPhysical="1"
    ProcessorClockFrequency="2200"
>
...
</Site>

Operating system information as well a bit of information about your
hardware are all collected with a log of the test suite output. Such
information is required in the nature of testing and CDash.

To provide us with even more useful information regarding your building
and testing experience (and it's recommended to do this if you build from
source), invoke the entire configuring, build, execution and test system.
Such information provides developers with valuable information. There's three
tags used for such purposes, but the other two ('Continuous' and 'Nightly')
are reserved for automated builds. Invoke the following:

    $ make Experimental                     # invokes all of the Experimental commands.

CMake will then switch over to the CTest system and begin executing the tests
that are packaged along with the source code. There's typically two sectors of
tests, one of the library and another of the front-end's internal API. This
allows developers and testers to catch potential glitches and iron out ways to
prevent these issues from occurring again.

The output from the make command may be a bit verbose for some, so instead you
can do the following (from ${CMAKE_BINARY_DIR}/tests):

    $ ctest
    $ make tests                # Builds the tests and then invokes 'ctest'.

This'll invoke the CTest system directly, however, the tests themselves have to
be built before you invoke this command. As a means of shorthand, you can just
use the 'tests' target to build and then execute all of the tests.
